#!/bin/bash

count=false
path_arg="." # Use a different name for the input argument
xdev_enabled=true # Default to staying on the same filesystem
top_n_count=0

# --- Options for du and find ---
du_opts=()
find_opts=()

# Help message
show_help() {
    echo "
Usage: size [options] [path]

  Without arguments, shows the size of the current directory (excluding other mounted filesystems).

Options:
  -c          Also count the number of files and directories.
  -a, --all-filesystems
              Traverse all filesystems. By default, stays on the same filesystem
              as the path being processed.
  -t N, --top N
              Show the top N largest files/directories immediately under the path.
              (e.g., -t 5)
  -h, --help  Show this help message.

Examples:
  size               Show size of current directory
  size -c /mnt       Show size + counts of /mnt
  size -a /          Show size of / including all mounted filesystems
  size -t 5 /var     Show size of /var and the 5 largest items in it
"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -c)
            count=true
            shift
            ;;
        -a|--all-filesystems)
            xdev_enabled=false
            shift
            ;;
        -t|--top)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ && "$2" -gt 0 ]]; then
                top_n_count="$2"
                shift 2
            else
                echo "Error: --top (-t) requires a positive integer argument." >&2
                exit 1
            fi
            ;;
        -*)
            echo "Invalid option: $1" >&2
            show_help
            exit 1
            ;;
        *)
            if [[ "$path_arg" == "." ]]; then
                path_arg="$1"
                shift
            else
                echo "Error: Multiple paths provided. Please specify only one directory." >&2
                exit 1
            fi
            ;;
    esac
done

# Set du and find options based on xdev_enabled
if [ "$xdev_enabled" = true ]; then
    du_opts+=("-x")
    find_opts+=("-xdev")
fi

# Resolve absolute path, stripping any trailing slash for consistency
path=$(realpath -s "$path_arg") # Use -s to strip trailing slashes
start_time=$(date +%s.%N)

# Validate path
if [[ ! -e "$path" ]]; then # Check if path exists at all first
    echo "size: Error: '$path' does not exist." >&2
    exit 1
elif [[ -f "$path" ]]; then
    echo "size: Warning: '$path' is a file, not a directory. Displaying file size."
    # For files, du -sh works directly, count is 1 file, 0 dirs.
    size_info=$(du -h "${du_opts[@]}" "$path" 2>/dev/null | awk '{print $1}')
    if [[ "$count" = true ]]; then
        echo "$path is ${size_info} (1 file, 0 directories)"
    else
        echo "$path is ${size_info}"
    fi
    # Filesystem info for a file is same as for its parent dir
    df_output=$(df -h "$(dirname "$path")" 2>/dev/null | tail -n 1)
    # ... (rest of df processing)
else if [[ ! -d "$path" ]]; then # If not a file and not a directory (e.g. broken symlink after realpath)
    echo "size: Error: '$path' is not a valid directory or file." >&2
    exit 1
fi
# Proceed if it's a directory (or a file, handled above slightly differently)

# Try to get size info for directory, handling permission issues
if [[ -d "$path" ]]; then # Only do full du if it's a directory
    size_info=$(du -sh "${du_opts[@]}" "$path" 2>/dev/null | awk '{print $1}')
fi

if [[ -z "$size_info" ]]; then
    size_info="Permission denied or inaccessible"
fi

# Disk usage from df
# For df, use the original path_arg if path is a symlink, otherwise realpath is fine.
# Or, more simply, realpath should give the canonical path which df can use.
df_path_target="$path"
if [[ -L "$path_arg" && ! -d "$path_arg" && -d "$path" ]]; then
    # If original path_arg was a symlink to a directory, df on the symlink itself
    # might be more intuitive for some df versions/outputs regarding the device.
    # However, df on the resolved path ($path) is generally more robust.
    df_path_target="$path"
fi

df_output=$(df -hP "$df_path_target" 2>/dev/null | tail -n 1) # Added -P for POSIX standard output
device=$(echo "$df_output" | awk '{print $1}')
total_size=$(echo "$df_output" | awk '{print $2}') # Renamed 'size' to 'total_size' to avoid conflict
used=$(echo "$df_output" | awk '{print $3}')
available=$(echo "$df_output" | awk '{print $4}')
use_percent=$(echo "$df_output" | awk '{print $5}')


# Output main info
if [[ -d "$path" ]]; then # Only show counts if it's a directory
    if [ "$count" = true ]; then
        # Using path for find context
        dir_count=$(find "$path" "${find_opts[@]}" -type d 2>/dev/null | wc -l | awk '{printf "%'\''d\n", $1}')
        file_count=$(find "$path" "${find_opts[@]}" -type f 2>/dev/null | wc -l | awk '{printf "%'\''d\n", $1}')
        echo "$path is ${size_info} (with $file_count files, $dir_count directories)"
    else
        echo "$path is ${size_info}"
    fi
else # It's a file (already printed above, but for structure, this is where file output would be)
    : # Handled earlier in the file check block
fi


echo "Located on $device, $use_percent used ($used of $total_size, $available available)"


# Top N largest items
if [[ "$top_n_count" -gt 0 && -d "$path" ]]; then
    echo "" # Add a blank line for readability
    echo "Top $top_n_count largest items in $path:"
    # Escape path for grep pattern: replaces regex special characters with their escaped versions
    path_escaped_for_grep=$(printf '%s\n' "$path" | sed 's:[][\/.^$*]:\\&:g')
    # du --max-depth=1 lists items in $path and $path itself with its total.
    # We grep -v to exclude the line for $path itself.
    top_items_output=$(du -h "${du_opts[@]}" --max-depth=1 "$path" 2>/dev/null |
        grep -Ev "^\S+\s+${path_escaped_for_grep}$" | # Filter out the total for the path itself
        sort -rh |
        head -n "$top_n_count")

    if [[ -n "$top_items_output" ]]; then
        echo "$top_items_output"
    else
        echo "  (No items found or items are inaccessible)"
    fi
fi

# Time taken
end_time=$(date +%s.%N)
elapsed_time_raw=$(echo "$end_time - $start_time" | bc)
elapsed_time_formatted=$(LC_NUMERIC=C printf "%.1f" "$elapsed_time_raw")

# Check if elapsed_time_formatted is a valid number before using it in bc
if [[ "$elapsed_time_formatted" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
    if (( $(echo "$elapsed_time_formatted >= 10" | bc -l) )); then
        echo "(Script ran for ${elapsed_time_formatted}s)"
    fi
else
    # This case handles if printf failed and elapsed_time_formatted is not a number
    echo "(Could not calculate script run time accurately)"
fi

exit 0
