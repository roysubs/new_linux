#!/bin/bash

# Check if a value is a positive integer
is_number() {
    # Use arithmetic check for simple integer validation
    [ "$1" -eq "$1" ] 2>/dev/null
}

# Check if a value is an existing directory
is_directory() {
    [[ -d "$1" ]]
}

# Validate parameter format (allowing +/-number or just number)
validate_sign_num() {
    [[ "<span class=\"math-inline">1" \=\~ ^\[\+\-\]?\[0\-9\]\+</span>\" ]]
}

# --- Usage Message ---
show_usage() {
    echo "Find Helper. Usage: $(basename "$0") <command> [parameter] [num_results] [directory] [-s]"
    # FIX: Removed the problematic unclosed echo line
    echo # This provides a blank line for formatting
    echo "Commands:"
    echo "  Generic Filters (find all matching, no default num_results limit unless specified):"
    echo "    name <pattern>     - Find files/dirs by name pattern (e.g., '*.log')"
    echo "    type <letter>     - Find by type (d=dir, f=file, l=symlink, p=pipe, s=socket, b=block, c=char)"
    echo "    empty             - Find empty files or directories"
    echo "    size_M <+/-size> - Find files by size in MB (e.g., +100 for >100MB, -5 for <5MB)"
    echo "    perm <mode>       - Find files/dirs with specific permissions (e.g., 644, /u+x)"
    echo "    owner <user>      - Find files/dirs owned by user (name or UID)"
    echo "    group <group>     - Find files/dirs owned by group (name or GID)"
    echo "    mtime_days <+/-days> - Find by modification time in days (e.g., +7, -30)"
    echo "    mtime_mins <+/-mins> - Find by modification time in minutes (e.g., +60, -120)"
    echo "    atime_days <+/-days> - Find by access time in days"
    echo "    atime_mins <+/-mins> - Find by access time in minutes"
    echo "    ctime_days <+/-days> - Find by change time in days"
    echo "    ctime_mins <+/-mins> - Find by change time in minutes"
    echo "    exec              - Find executable files"
    echo "    readable          - Find readable files"
    echo "    writable          - Find writable files"
    echo "    corrupt          - Find potentially corrupted files (heuristic using 'file')"
    echo
    echo "  Ranked Lists (show top N, num_results defaults to 20):"
    echo "    big               - Find the largest files"
    echo "    small             - Find the smallest files"
    echo "    old               - Find the oldest files (by mtime)"
    echo "    recent            - Find the most recently modified files (by mtime)"
    echo "    unused <days>     - Find oldest files (by atime) not accessed in days"
    echo
    echo "Options:"
    echo "  parameter   - (required for some commands) Specific value for the command (size, mode, name, etc.)"
    echo "  num_results - (optional) Number of results to display for Ranked Lists (default: 20). Can limit output for other commands."
    echo "  directory   - (optional) Target directory (default: current directory)"
    echo "  -s          - (optional) Use sudo for the find command (useful for restricted directories like /root or /var/log)"
    echo
    echo "Examples:"
    echo "  ff big 50 /var/log -s" # Added -s to example
    echo "  ff name '*.conf' /etc -s"
    echo "  ff size_M +1024"
    echo "  ff mtime_days -1"
    echo "  ff unused 30 /home"
    echo "  ff type d /tmp"
    exit 0
}

# Show usage if no arguments or -h is passed
if [[ $# -eq 0 || "$1" == "-h" ]]; then
    show_usage
fi

# --- Argument Parsing ---

cmd="$1"
num_results=20
target_dir="."
use_sudo=""
cmd_params=() # Store non-standard args here

# Process arguments (skip command <span class="math-inline">1\)
for arg in "</span>{@:2}"; do # Loop from the second argument onwards
    if [[ "$arg" == "-s" ]]; then
        use_sudo="sudo"
    # Check if it's a number AND we haven't set num_results from an explicit argument yet
    # NOTE: This simple parsing assumes num_results is the first number encountered after the command
    # if it hasn't been set, which might be ambiguous if a parameter is also a number.
    # A more robust parser could be implemented, but this matches the original logic.
    elif is_number "$arg" && [[ $num_results -eq 20 ]]; then
        # If it's a number and num_results is still default, treat as num_results
        num_results="$arg"
    # Check if it's a directory AND we haven't set target_dir from an explicit argument yet
    # NOTE: Similar ambiguity as with num_results if a parameter could also be a valid directory path.
    elif is_directory "$arg" && [[ "$target_dir" == "." ]]; then
        # If it's a directory and target_dir is still default, treat as target_dir
        target_dir="$arg"
    else
        # Otherwise, treat as a command parameter
        cmd_params+=("$arg")
    fi
done

# --- Define Find Commands Based on Case ---

find_cmd=""
needs_head=true # Assume we need 'head' unless the command is a pure filter

case "$cmd" in
    # --- Ranked Lists ---
    big)
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'big' command takes no parameters."; show_usage; fi
        # Use \n for find's printf, remove --from=- from numfmt
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type f -printf '%s %p\n' | sort -nr | numfmt --to=iec"
        ;;
    small)
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'small' command takes no parameters."; show_usage; fi
        # Use \n for find's printf, remove --from=- from numfmt
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type f -printf '%s %p\n' | sort -n | numfmt --to=iec"
        ;;
    old)
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'old' command takes no parameters."; show_usage; fi
         # Use \n for find's printf
        # FIX: Changed substr($0,2) to $0 after $1="" in awk
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type f -printf '%T@ %p\n' | sort -n | awk '{timestamp = \$1; \$1 = \"\"; print strftime(\"%Y-%m-%d %H:%M:%S\", timestamp), \$0}'"
        ;;
    recent)
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'recent' command takes no parameters."; show_usage; fi
         # Use \n for find's printf
        # FIX: Changed substr($0,2) to $0 after $1="" in awk
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type f -printf '%T@ %p\n' | sort -nr | awk '{timestamp = \$1; \$1 = \"\"; print strftime(\"%Y-%m-%d %H:%M:%S\", timestamp), \$0}'"
        ;;
    unused)
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'unused' command requires one parameter\: <days\>\."; show\_usage; fi
days\="</span>{cmd_params[0]}"
        if ! is_number "$days"; then echo "Error: days for 'unused' must be a number."; show_usage; fi
        # Find files not accessed in +days, then sort by access time (oldest) %A@
        # Use \n for find's printf
        # FIX: Changed substr($0,2) to $0 after $1="" in awk
        find_cmd="$use_sudo find \"<span class="math-inline">target\_dir\\" \-xdev \-type f \-atime \+</span>{days} -printf '%A@ %p\n' | sort -n | awk '{timestamp = \$1; \$1 = \"\"; print strftime(\"%Y-%m-%d %H:%M:%S\", timestamp), \$0}'"
        ;;

    # --- Generic Filters ---
    name)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'name' command requires one parameter\: <pattern\>\."; show\_usage; fi
pattern\="</span>{cmd_params[0]}"
        # Use -name directly, no type f limitation here, allow finding dirs/links by name too
        find_cmd="$use_sudo find \"<span class="math-inline">target\_dir\\" \-xdev \-name \\"</span>{pattern}\""
        ;;
    type)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'type' command requires one parameter\: <letter\>\."; show\_usage; fi
type\_letter\="</span>{cmd_params[0]}"
        # Validate type letter
        if ! [[ "<span class="math-inline">type\_letter" \=\~ ^\[dfplsbc\]</span> ]]; then echo "Error: Invalid type letter '$type_letter'. Use d, f, l, p, s, b, or c."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type \"$type_letter\""
        ;;
    empty)
        needs_head=false
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'empty' command takes no parameters."; show_usage; fi
        # Find empty files or directories
        find_cmd="$use_sudo find \"$target_dir\" -xdev -empty"
        ;;
    size_M)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'size\_M' command requires one parameter\: <\+/\-size\>\."; show\_usage; fi
size\_param\="</span>{cmd_params[0]}"
        # Validate size parameter format (allowing just a number)
        if ! validate_sign_num "$size_param"; then echo "Error: Invalid size format '$size_param'. Use like +100, -5, or 5."; show_usage; fi
        # Append M for Megabytes, Use \n for find's printf, remove --from=- from numfmt
        # For pure filters, we don't necessarily need the size output unless the user wants it.
        # The original printed size. Let's keep that for consistency, but remove numfmt.
        # Or, just let find output the path directly as it's a generic filter.
        # Let's revert to just find outputting the path, as size/time is already checked by find.
        # find_cmd="$use_sudo find \"<span class="math-inline">target\_dir\\" \-xdev \-type f \-size \\"</span>{size_param}M\" -printf '%s %p\n' | numfmt --to=iec" # Original
        find_cmd="$use_sudo find \"<span class="math-inline">target\_dir\\" \-xdev \-type f \-size \\"</span>{size_param}M\"" # Simplified for generic filter
        ;;
    perm)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'perm' command requires one parameter\: <mode\>\."; show\_usage; fi
mode\="</span>{cmd_params[0]}"
        # Note: find -perm can take octal (755) or symbolic (/u+x) modes. No validation needed beyond presence.
        find_cmd="$use_sudo find \"$target_dir\" -xdev -perm \"$mode\""
        ;;
    owner)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'owner' command requires one parameter\: <user\>\."; show\_usage; fi
user\="</span>{cmd_params[0]}"
        find_cmd="$use_sudo find \"$target_dir\" -xdev -user \"$user\""
        ;;
    group)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'group' command requires one parameter\: <group\>\."; show\_usage; fi
group\_name\="</span>{cmd_params[0]}"
        find_cmd="$use_sudo find \"$target_dir\" -xdev -group \"$group_name\""
        ;;
    mtime_days)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'mtime\_days' command requires one parameter\: <\+/\-days\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-days '$time_param'. Use like +7, -30, or 1."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -mtime ${time_param}"
        ;;
    mtime_mins)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'mtime\_mins' command requires one parameter\: <\+/\-minutes\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-minutes '$time_param'. Use like +60, -120, or 5."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -mmin ${time_param}"
        ;;
    atime_days)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'atime\_days' command requires one parameter\: <\+/\-days\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-days '$time_param'. Use like +7, -30, or 1."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -atime ${time_param}"
        ;;
    atime_mins)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'atime\_mins' command requires one parameter\: <\+/\-minutes\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-minutes '$time_param'. Use like +60, -120, or 5."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -amin ${time_param}"
        ;;
    ctime_days)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'ctime\_days' command requires one parameter\: <\+/\-days\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-days '$time_param'. Use like +7, -30, or 1."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -ctime ${time_param}"
        ;;
    ctime_mins)
        needs_head=false
        if [[ <span class="math-inline">\{\#cmd\_params\[@\]\} \-ne 1 \]\]; then echo "Error\: 'ctime\_mins' command requires one parameter\: <\+/\-minutes\>\."; show\_usage; fi
time\_param\="</span>{cmd_params[0]}"
        if ! validate_sign_num "$time_param"; then echo "Error: Invalid format for +/-minutes '$time_param'. Use like +60, -120, or 5."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -cmin ${time_param}"
        ;;
    exec)
        needs_head=false
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'exec' command takes no parameters."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -executable"
        ;;
    readable)
        needs_head=false
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'readable' command takes no parameters."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -readable"
        ;;
    writable)
        needs_head=false
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'writable' command takes no parameters."; show_usage; fi
        find_cmd="$use_sudo find \"$target_dir\" -xdev -writable"
        ;;
    corrupt)
        needs_head=false
        if [[ ${#cmd_params[@]} -ne 0 ]]; then echo "Error: 'corrupt' command takes no parameters."; show_usage; fi
        # Using -exec file {} \; is relatively slow as it starts a new 'file' process for each file.
        # A more efficient approach is often 'find ... -print0 | xargs -0 file'.
        # However, the current -exec format is more direct and educational for 'find'.
        # The escaped semicolon and pipe are correct for eval.
        find_cmd="$use_sudo find \"$target_dir\" -xdev -type f -exec file {} \\; \| grep -i 'corrupt'"
        ;;

    *)
        echo "Error: Unknown command '$cmd'. Use -h for help."
        show_usage
        ;;
esac

# --- Execute Command ---

# Append head limit if it's a ranked list command or if num_results was explicitly set and not 20
final_cmd="$find_cmd"
# Apply head if needs_head is true OR if num_results was set to something other than the default 20
if [[ "$needs_head" == true || $num_results -ne 20 ]]; then
    final_cmd+=" | head -n $num_results"
fi

# Display the command before execution (educational!)
# Use echo "$final_cmd" inside echo -e to display \n literally
echo -e "\033[0;32m# $(echo "<span class="math-inline">final\_cmd"\)\\033\[0m" \# Changed prefix to \# and kept green
echo
\# Start timer
start\_time\=</span>(date +%s)

# Execute the command
# Using eval is necessary because the find_cmd string is built dynamically
eval "<span class="math-inline">final\_cmd"
\# End timer and calculate duration
end\_time\=</span>(date +%s)
elapsed=$((end_time - start_time))

# Display execution time
echo -e "\nExecution time: ${elapsed} seconds"
