#!/bin/bash

# Git Tool Script
# Provides utilities for common Git operations and troubleshooting.

# Store the directory where the script was invoked
INVOCATION_DIR="$(pwd)"

if [ $# -eq 0 ]; then
    echo "Git Tool. Usage: g [option] <args>"
    echo "Options:"
    echo "  acp <message>     Add-Commit-Push: status, add -A, gitleaks detect, commit -m <message>, push"
    echo "                    Also accepts --debug to show ssh -v output during the push operation"
    echo "  a                 Add all changes from current folder only:   git add ."
    echo "  A                 Add (stage) all changes from the root of the repo and all subfolders:   git add -A"
    echo "  c <message>       Commit:  git commit -m <message>"
    echo "  s                 Status:  Show the current repository status"
    echo "  set-ssh           If you cloned a repo as HTTPS, change it to SSH so that you can push"
    echo "                    git remote set-url origin git@github.com:roysubs/new_linux.git"
    echo "  ps|push           Push: Update to the current branch's upstream"
    echo "  pl|pull           Pull: Update latest changes from the remote to local"
    echo "  cl|clone          Clone a full project from a git repository and report stats"
    echo "  cl1               Clone, but with max depth 1 only, and report stats"
    echo "  d|diff            Diff: Show unstaged changes"
    echo "  ds                Diff Staged: Show staged changes"
    echo "  l|log             Log: Show commit history (short format)"
    echo "  ll                Log Detailed: Show full commit history with diffs"
    echo "  b                 Branch: List branches, highlight current branch"
    echo "  ch|co|checkout <branch>   Checkout: Switch to a different branch"
    echo "  nb <name>         New Branch: Create and switch to a new branch"
    echo "  rpo               git remote prune origin (prune branches that no longer exist)"
    echo "  f                 Fetch: Update remote refs without merging"
    echo "  m <branch>        Merge: Merge the specified branch into the current one"
    echo "  rs <commit>       Reset Soft: Reset to the given commit but keep changes"
    echo "  rh <commit>       Reset Hard: Reset to the given commit and discard changes"
    echo "  stash             Stash: Save uncommitted changes"
    echo "  stpush <message>  Stash with a message"
    echo "  stpop             Pop last stash"
    echo "  cl!               Clean untracked files (DANGEROUS: Run with caution!)"
    echo "  t                 Troubleshooting Help: Show common Git fixes"
    echo
    exit 0
fi

echo_blue() {
    echo -e "\033[1;34m$@\033[0m"
}

display_and_run() {
    echo -e "\033[1;34m$@\033[0m"
    eval "$@"
}

echo_red() {
    echo -e "\033[1;31m$@\033[0m"
}

option=$1
shift  # Shift to access arguments

# --- Conditional CD to Project Root ---
# Only change directory to project root if the command requires it.
# Commands like 'cl' and 'cl1' should run in the INVOCATION_DIR.
case "$option" in
    a|A|c|s|acp|ps|push|pl|pull|d|diff|ds|l|log|ll|b|ch|co|checkout|nb|rpo|f|m|rs|rh|stash|stpush|stpop|clear|t)
        # Determine project root only if needed
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)" # Gets directory of this script
        PROJECT_ROOT="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null)" # Use 2>/dev/null to suppress error if not in a repo

        if [ -n "$PROJECT_ROOT" ] && [ -d "$PROJECT_ROOT" ]; then
            cd "$PROJECT_ROOT" || { echo "Error: Could not change to project root."; exit 1; }
            # echo "Changed directory to project root: $(pwd)"
        else
            # For commands that need a repo, if not in one, show error
            if [[ "$option" != "t" ]]; then # 't' doesn't strictly need a repo
                 echo "Error: Could not determine project root. Run this command from within a Git repository."
                 exit 1
            fi
        fi
        ;;
    cl|clone|cl1)
        # These commands should run in the INVOCATION_DIR, so no cd here.
        # Ensure we are in the directory where the script was called.
        cd "$INVOCATION_DIR" || { echo "Error: Could not return to invocation directory."; exit 1; }
        ;;
    *)
        # For unknown options, stay in INVOCATION_DIR or handle as default case below
        cd "$INVOCATION_DIR" || { echo "Error: Could not return to invocation directory."; exit 1; }
        ;;
esac
# --- End Conditional CD ---


case "$option" in
    a)
        git add .
        ;;

    A)
        git add -A
        ;;

    cl|clone|cl1)
        INPUT_URL="$1" # Store the original input
        REPO_URL=""    # Variable to hold the final constructed URL

        if [ -z "$INPUT_URL" ]; then
            echo_red "❌ Error: Repository URL or shorthand is required for clone."
            exit 1
        fi

        # Check for shorthand formats
        if [[ "$INPUT_URL" =~ ^gl/ ]]; then
            # GitLab shorthand: gl/user/repo
            REPO_PATH="${INPUT_URL#gl/}" # Remove 'gl/' prefix
            REPO_URL="https://gitlab.com/${REPO_PATH}"
            echo_blue "Detected GitLab shorthand. Cloning from: $REPO_URL"
        elif [[ "$INPUT_URL" =~ / ]]; then
            # Assume GitHub shorthand: user/repo
            REPO_URL="https://github.com/${INPUT_URL}"
            echo_blue "Detected GitHub shorthand. Cloning from: $REPO_URL"
        else
            # Assume it's a full URL or other format
            REPO_URL="$INPUT_URL"
            echo_blue "Assuming full URL or other format. Cloning from: $REPO_URL"
        fi

        # Extract the directory name from the URL
        # Handles various URL formats (https, ssh, git)
        # Use sed to extract the last part of the path before .git or the end
        CLONE_DIR=$(echo "$REPO_URL" | sed -E 's/.*\/([^/]+)(\.git)?$/\1/')

        if [ -z "$CLONE_DIR" ]; then
             echo_red "❌ Error: Could not determine clone directory name from URL: $REPO_URL"
             exit 1
        fi

        # Add depth=1 for cl1
        CLONE_ARGS=("$REPO_URL") # Start with the constructed URL
        shift # Shift off the original input URL ($1)
        CLONE_ARGS+=("$@") # Add any remaining arguments (like a specific directory name)

        if [ "$option" = "cl1" ]; then
            CLONE_ARGS+=("--depth=1")
        fi

        display_and_run "git clone ${CLONE_ARGS[*]}"

        # Check if clone was successful
        if [ $? -ne 0 ]; then
            echo_red "❌ Git clone failed."
            exit 1
        fi

        # --- Get size and number of files/folders ---
        echo_blue "Gathering statistics for the cloned repository..."
        # Check if the cloned directory exists. If the user provided a custom directory name,
        # CLONE_DIR might not be the actual directory name. We need to find the actual directory.
        # git clone outputs the directory name it created on success, but capturing that
        # reliably can be tricky with display_and_run. A simpler approach is to check
        # if the determined CLONE_DIR exists, and if not, check if git status works
        # inside a potential new directory created by git clone in the INVOCATION_DIR.

        ACTUAL_CLONE_DIR=""
        if [ -d "$CLONE_DIR" ]; then
            ACTUAL_CLONE_DIR="$CLONE_DIR"
        else
            # If CLONE_DIR doesn't exist, it might be because the user specified
            # a custom directory name as an argument after the URL.
            # We can try to find the directory created by git clone in INVOCATION_DIR.
            # This is a bit heuristic, assuming git clone created a *new* directory.
            # A more robust solution would involve parsing git clone output or
            # checking for a .git directory in new folders. For now, let's
            # assume the default behavior or a simple custom name.
            # We'll stick to checking the derived CLONE_DIR for simplicity.
            # If a custom directory was provided, the user would need to run stats manually.
            # Let's add a note about this limitation.
            echo_red "⚠️ Warning: Cloned directory '$CLONE_DIR' not found. If you specified a custom directory name during clone, stats will not be automatically gathered."
            echo_blue "To get stats for a custom directory, navigate into it and run 'du -sh .', 'find . -type f | wc -l', and 'find . -type d -mindepth 1 | wc -l'."
            # Return to the directory where the script was invoked
            cd "$INVOCATION_DIR" || { echo_red "❌ Error: Could not return to invocation directory after clone failure."; exit 1; }
            exit 0 # Exit successfully as clone itself might have worked, just stats failed
        fi

        # Proceed with stats if ACTUAL_CLONE_DIR was found
        if [ -n "$ACTUAL_CLONE_DIR" ]; then
             cd "$ACTUAL_CLONE_DIR" || { echo_red "❌ Error: Could not change to cloned directory '$ACTUAL_CLONE_DIR'."; exit 1; }

            # Count files (excluding directories)
            FILE_COUNT=$(find . -type f | wc -l)

            # Count directories
            # Use -mindepth 1 to exclude the current directory '.'
            DIR_COUNT=$(find . -type d -mindepth 1 | wc -l)

            # Calculate total size (human-readable format)
            # Use -s for summary, -h for human-readable, '.' for current directory
            TOTAL_SIZE=$(du -sh .)

            echo_blue "Clone successful!"
            echo "Repository: $ACTUAL_CLONE_DIR"
            echo "Number of files: $FILE_COUNT"
            echo "Number of folders: $DIR_COUNT"
            echo "Total size: $TOTAL_SIZE"

            # Return to the directory where the script was invoked
            cd "$INVOCATION_DIR" || { echo_red "❌ Error: Could not return to invocation directory after stats."; exit 1; }
        fi
        ;;
 
    c)
        git commit -m "$@"
        ;;

    s)
        git status
        ;;

    acp)
        DEBUG_MODE=0
        COMMIT_MSG=()

        while [[ $# -gt 0 ]]; do
            case "$1" in
                --debug)
                    DEBUG_MODE=1
                    ;;
                *)
                    COMMIT_MSG+=("$1")
                    ;;
            esac
            shift
        done

        if [[ ${#COMMIT_MSG[@]} -eq 0 ]]; then
            echo -e "\033[1;31m❌ No commit message provided.\033[0m"
            exit 1
        fi

        COMMIT_STR="${COMMIT_MSG[*]}"

        echo "====="
        display_and_run "git status --short"

        echo "====="
        display_and_run "git add -A --verbose"

        echo "====="
        echo "Scanning for secrets using Gitleaks; do NOT commit without this (to avoid awkward rebase issues)..."
        if ! command -v gitleaks >/dev/null 2>&1; then
            echo -e "\033[1;31m❌ Error: gitleaks command not found.\033[0m"
            echo "Please install gitleaks (e.g., 'sudo apt install gitleaks') and try again. Currently, the Ubuntu apt repo"
            echo "does include this, but the Debian repo does not. However, it can be installed from GitHub."
            echo "See also the gitleaks-get.sh script in the 0-install folder in this project which can install it."
            exit 1
        fi
        display_and_run "gitleaks detect --no-git . --verbose"

        if [ $? -ne 0 ]; then
            echo -e "\033[1;31m❌ Secret scan failed! Fix detected secrets in your workspace before committing.\033[0m"
            echo "Review the output above for details on detected secrets."
            exit 1
        fi

        echo "Secret scan passed. Proceeding with commit."

        echo "====="
        display_and_run "git commit --verbose -m \"$COMMIT_STR\"" || {
            echo -e "\033[1;31m❌ Commit failed. Aborting push.\033[0m"
            exit 1
        }

        echo "====="
        CURRENT_BRANCH=$(git symbolic-ref --short HEAD)

        if [[ $DEBUG_MODE -eq 1 ]]; then
            display_and_run "GIT_SSH_COMMAND='ssh -v' git push origin $CURRENT_BRANCH"
        else
            read -rp "✅ Ready to push to origin/$CURRENT_BRANCH — press ENTER to confirm or Ctrl+C to cancel... "
            display_and_run "git push origin $CURRENT_BRANCH"
        fi
        ;;

    ps|push)
        git push
        ;;

    pl|pull)
        git pull
        ;;

    d|diff)
        git diff
        ;;

    ds)
        git diff --staged
        ;;

    l|log)
        git log --oneline --graph --decorate --all
        ;;

    ll)
        git log --stat --patch
        ;;

    b|branch)
        git branch --sort=-committerdate --color | sed -e '/^\*/!s/^/  /'
        ;;

    ch|co|checkout)
        if [ -z "$1" ]; then
            echo_red "❌ Error: Branch name is required for checkout."
            exit 1
        fi
        git checkout "$1"
        ;;

    nb)
         if [ -z "$1" ]; then
            echo_red "❌ Error: Branch name is required for new branch."
            exit 1
        fi
        git checkout -b "$1"
        ;;

    rpo)
        git remote prune origin
        ;;

    f)
        git fetch
        ;;

    m)
        if [ -z "$1" ]; then
            echo_red "❌ Error: Branch name is required for merge."
            exit 1
        fi
        git merge "$1"
        ;;

    rs)
        if [ -z "$1" ]; then
            echo_red "❌ Error: Commit hash is required for soft reset."
            exit 1
        fi
        git reset --soft "$1"
        ;;

    rh)
        if [ -z "$1" ]; then
            echo_red "❌ Error: Commit hash is required for hard reset."
            exit 1
        fi
        git reset --hard "$1"
        ;;

    stash)
        git stash
        ;;

    stpush)
        if [ -z "$1" ]; then
            echo_red "❌ Error: Message is required for stash push."
            exit 1
        fi
        git stash push -m "$1"
        ;;

    stpop)
        git stash pop
        ;;

    clear)
        echo "WARNING: This will delete untracked files! Use with caution."
        read -p "Are you sure? (y/N) " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git clean -fd
        else
            echo "Aborted."
        fi
        ;;

    set-git)
        # Check if a URL argument was provided ($2)
        if [ -z "$2" ]; then
            # No URL provided, show explanation
            echo "Understanding Git Remote URLs: HTTPS vs SSH"
            echo "--------------------------------------------"
            echo "Git uses a 'remote' URL to know where to fetch from and push to."
            echo "There are two main types for services like GitHub, GitLab, etc:"
            echo ""
            echo "1. HTTPS (e.g., https://github.com/user/repo.git)"
            echo "   - Authentication requires username/password or Personal Access Token (PAT)."
            echo "   - Can be simpler for cloning initially, but requires re-authentication"
            echo "     or a credential helper (which might store credentials)."
            echo "   - Password authentication is deprecated/banned on GitHub if you use 2FA."
            echo ""
            echo "2. SSH (e.g., git@github.com:user/repo.git)"
            echo "   - Authentication uses SSH keys (public key on server, private key on your machine)."
            echo "   - Recommended method for scripting and frequent use, especially with 2FA."
            echo "   - Requires generating an SSH key pair and adding the public key to your Git hosting service."
            echo "   - No username/password prompt during operations (unless your SSH key has a passphrase)."
            echo ""
            echo "You likely want to switch to SSH if you have set up SSH keys on GitHub/GitLab/etc."
            echo "Check that with 'git remote -v' (if it shows https:// then you should switch)."
            echo ""
            echo "To change the 'origin' remote URL of the current repository, use:"
            echo "g set-ssh <your_ssh_url>"
            echo ""
            echo "Example (replace with your actual username and repo name):"
            echo "g set-ssh git@github.com:roysubs/new_linux.git"
            echo ""
            echo "Which will run:"
            echo "git remote set-url origin git@github.com:roysubs/new_linux.git"
            echo ""
        else
            # URL provided, attempt to set the remote URL
            NEW_REMOTE_URL="$2"
            echo "===== Setting 'origin' remote URL to: $NEW_REMOTE_URL ====="
            git remote set-url origin "$NEW_REMOTE_URL"

            # Check the exit status of the git command
            if [ $? -eq 0 ]; then
                echo "✅ Successfully updated 'origin' remote URL."
                echo "Verify with:"
                echo "git remote -v"
            else
                echo_red "❌ Error: Failed to set 'origin' remote URL."
                echo "Check the URL format and try again."
            fi
            echo "========================================================="
        fi
        ;;

    t)
        echo "Git Troubleshooting Help:"
        echo "  - If a merge conflict occurs: git status, then edit and resolve conflicts."
        echo "  - To undo last commit but keep changes: g rs HEAD~1"
        echo "  - To forcefully reset to last commit: g rh HEAD"
        echo "  - If 'detached HEAD' appears: g ch <branch>"
        echo "  - If a push is rejected due to conflicts: g f && g ps"
        echo "  - To delete a local branch: git branch -d <branch>"
        echo "  - To delete a remote branch: git push origin --delete <branch>"
        echo
        ;;

    *)
        echo "Invalid option. Use 'g' without arguments to see usage."
        exit 1 # Exit with error for invalid option
        ;;

esac

