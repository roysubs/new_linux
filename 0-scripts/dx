#!/usr/bin/env bash

# d - Directory size summary with relative sizes and optional file/dir counts

set -euo pipefail
shopt -s nullglob dotglob

# --- Configuration ---
# Default mode: apparent size (file data bytes)
DU_FLAGS=(--apparent-size -s -B1)
SIZE_MODE_DESC="apparent size (file data bytes)"

SHOW_COUNTS=false
SHOW_HELP=false
START_TIME=$(date +%s)
SUDO=""
SORT_BY_NAME=false
TOP_N=0
DIR="."

# --- Option Parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help) SHOW_HELP=true ;;
        -c|--count) SHOW_COUNTS=true ;;
        --disk-usage)
            DU_FLAGS=(-s -B1)
            SIZE_MODE_DESC="actual disk usage (allocated disk blocks)"
            ;;
        -basic) shopt -u dotglob ;; # Exclude hidden files and directories
        -name) SORT_BY_NAME=true ;;
        -sudo) SUDO="sudo" ;;
        -top)
            shift
            [[ "$1" =~ ^[0-9]+$ ]] || { echo "Invalid -top argument: $1"; exit 1; }
            TOP_N="$1"
            ;;
        -*)
            echo "Unknown option: $1"
            exit 1
            ;;
        *) DIR="$1" ;;
    esac
    shift
done

DIR=$(eval echo "$DIR") # Expand potential ~ character

# --- Help Display ---
if $SHOW_HELP; then
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [DIRECTORY]

Calculates and displays sizes of subdirectories and loose files within a directory.

Default calculation shows apparent size (sum of file data bytes).

Options:
  -h, --help        Show this help message and exit.
  -c, --count       Show file and directory counts for each subdirectory.
  --disk-usage      Use actual disk usage (allocated blocks) instead of apparent file sizes.
  -basic            Ignore hidden files/directories (names starting with '.').
                    By default, hidden items are included.
  -name             Sort output by name instead of size (default is size descending).
  -sudo             Use sudo for 'du' and 'find' commands (needed for restricted directories).
  -top N            Show only the top N largest directories (plus loose files).

Default directory is the current directory ('.').
EOF
    exit 0
fi

echo "Calculating directory sizes in: $(realpath "$DIR")"
echo "(using ${SIZE_MODE_DESC})"

declare -A SIZES        # Associative array for directory sizes
declare -A NUM_FILES    # Associative array for file counts (if -c)
declare -A NUM_DIRS     # Associative array for directory counts (if -c)
TOTAL_SIZE=0            # Running total size (subdirs + loose files)
LOOSE_TOTAL=0           # Running total size for loose files only

# --- Collect Subdirectory Sizes ---
for d in "$DIR"/*/; do
    [[ -d "$d" && ! -L "$d" ]] || continue

    name=$(basename "$d")
    size=$($SUDO du "${DU_FLAGS[@]}" "$d" 2>/dev/null | cut -f1)
    [[ "$size" =~ ^[0-9]+$ ]] || continue

    SIZES["$name"]=$size
    (( TOTAL_SIZE += size ))

    if $SHOW_COUNTS; then
        files=$($SUDO find "$d" -type f 2>/dev/null | wc -l)
        dirs=$($SUDO find "$d" -type d 2>/dev/null | wc -l)
        NUM_FILES["$name"]=$files
        NUM_DIRS["$name"]=$((dirs - 1))
    fi
done

# --- Collect Loose File Sizes ---
while IFS= read -r -d '' file; do
    size=$($SUDO du "${DU_FLAGS[@]}" "$file" 2>/dev/null | cut -f1)
    [[ "$size" =~ ^[0-9]+$ ]] || continue
    (( LOOSE_TOTAL += size ))
done < <($SUDO find "$DIR" -mindepth 1 -maxdepth 1 -type f -print0)

(( TOTAL_SIZE += LOOSE_TOTAL ))

# --- Helper Function: Format Bytes to Human Readable ---
to_human() {
    local size=$1 B K M G T P
    if (( size == 0 )); then printf "0 B"; return; fi
    B=1 K=1024 M=$((1024*1024)) G=$((1024*1024*1024)) T=$((1024*1024*1024*1024)) P=$((1024*1024*1024*1024*1024))
    if (( size < K )); then printf "%d B" "$size"
    elif (( size < M )); then printf "%.1f KB" "$(bc <<< "scale=1; $size/$K")"
    elif (( size < G )); then printf "%.1f MB" "$(bc <<< "scale=1; $size/$M")"
    elif (( size < T )); then printf "%.1f GB" "$(bc <<< "scale=1; $size/$G")"
    elif (( size < P )); then printf "%.1f TB" "$(bc <<< "scale=1; $size/$T")"
    else                   printf "%.1f PB" "$(bc <<< "scale=1; $size/$P")"
    fi
}

# --- Output Formatting Setup ---
cols=$(tput cols || echo 80)
name_pad=25
size_pad=10
extra_pad=0
$SHOW_COUNTS && extra_pad=22
bar_space=$(( cols - name_pad - size_pad - extra_pad - 5 ))
(( bar_space < 10 )) && bar_space=10

# --- Print Header ---
if $SHOW_COUNTS; then
    printf "\n%-*s %*s  %10s %10s  %s\n" "$name_pad" "Directory/Item" "$size_pad" "Size" "NumFiles" "NumDirs" "Size Bar"
    printf "%-*s %*s  %10s %10s  %s\n" "$name_pad" "-------------------------" "$size_pad" "----------" "----------" "----------" "--------------------"
else
    printf "\n%-*s %*s  %s\n" "$name_pad" "Directory/Item" "$size_pad" "Size" "Size Bar"
    printf "%-*s %*s  %s\n" "$name_pad" "-------------------------" "$size_pad" "----------" "--------------------"
fi

# --- Sorting ---
declare -a sorted_names
if $SORT_BY_NAME; then
    mapfile -t sorted_names < <(printf "%s\n" "${!SIZES[@]}" | sort)
else
    mapfile -t sorted_names < <(
        for k in "${!SIZES[@]}"; do
            echo "$k ${SIZES[$k]}"
        done | sort -k2 -nr
    )
    declare -a temp_sorted_names
    while read -r name size; do
        temp_sorted_names+=("$name")
    done < <(
         for k in "${!SIZES[@]}"; do
             printf "%s %s\n" "$k" "${SIZES[$k]}"
         done | sort -k2 -nr
    )
    sorted_names=("${temp_sorted_names[@]}")
fi

# --- Apply -top N Filter ---
if (( TOP_N > 0 && ${#sorted_names[@]} > TOP_N )); then
    sorted_names=("${sorted_names[@]:0:TOP_N}")
fi

# --- Output Directory Details ---
for name in "${sorted_names[@]}"; do
    [[ -v SIZES["$name"] ]] || continue

    size="${SIZES[$name]}"
    barlen=0
    (( TOTAL_SIZE > 0 )) && barlen=$(( size * bar_space / TOTAL_SIZE ))
    bar=$(printf "%-${barlen}s" "o" | tr ' ' 'o')
    hsize=$(to_human "$size")

    if $SHOW_COUNTS; then
        printf "%-*s %*s  %10s %10s  [%s]\n" \
            "$name_pad" "$name" \
            "$size_pad" "$hsize" \
            "${NUM_FILES[$name]:-0}" "${NUM_DIRS[$name]:-0}" \
            "$bar"
    else
        printf "%-*s %*s  [%s]\n" \
            "$name_pad" "$name" \
            "$size_pad" "$hsize" \
            "$bar"
    fi
done

# --- Print Loose Files Summary ---
if (( LOOSE_TOTAL > 0 || $SHOW_COUNTS || ${#sorted_names[@]} > 0 )); then
    hsize=$(to_human "$LOOSE_TOTAL")
    barlen=0
    (( TOTAL_SIZE > 0 )) && barlen=$(( LOOSE_TOTAL * bar_space / TOTAL_SIZE ))
    bar=$(printf "%-${barlen}s" "o" | tr ' ' 'o')

    if $SHOW_COUNTS; then
         printf "%-*s %*s  %10s %10s  [%s]\n" "$name_pad" "** Loose Files:" "$size_pad" "$hsize" "-" "-" "$bar"
    else
         printf "%-*s %*s  [%s]\n" "$name_pad" "** Loose Files:" "$size_pad" "$hsize" "$bar"
    fi
fi

# --- Print Total Size Summary ---
printf "%-*s %*s\n" "$name_pad" "-------------------------" "$size_pad" "----------

